
## 1. Общая оценка стабильности API
По результатам тестирования покрыто 7 ключевых направлений:
- функциональность  
- классы эквивалентности  
- граничные значения  
- негативные сценарии  
- безопасность  
- rate limiting  
- работа ISBN-эндпоинтов  

Общее состояние API можно оценить как **стабильное**, за исключением четырёх выявленных аномалий.

## 2. Найденные аномалии (обобщение)
### 2.1. Критические / серьёзные
**(A1) 500 Internal Server Error на спецсимволах в q**  
Проблема:
- некорректная обработка входных данных
- Python исключение «conversion from NoneType to Decimal»

Риски:
- DoS через простые строки поиска  
- утечка внутренних ошибок (stacktrace)  
- нарушение инварианта “API не должен падать от пользовательского ввода”

### 2.2. Некритичные, но значимые
**(A2) Несоответствие ожиданиям: q длиной < 3 → 422 Ошибка  
Фактически:
- существует undocumented rule “минимум 3 символа”

Риски:
- невозможность использовать API как часть автодополнений/подсказок  
- несовместимость со сторонними клиентами  

### 2.3. XSS-тест вернул валидный JSON со строкой запроса
С точки зрения backend:
- это PASS  
С точки зрения frontend:
- API не фильтрует входные данные  
Риски:
- при некорректной обработке JSON на стороне клиента возможно отображение ввода без escaping

## 3. Покрытие тестами (Coverage Analysis)
Параметр `q` проверен по полному набору техник:
- **5 классов эквивалентности**  
- **4 граничные длины**  
- **XSS/SQLi/спецсимволы/Unicode**  
- **отсутствующий параметр**  
- **неверный HTTP method**  

Покрытие можно считать **высоким**, уровень Senior QA.

Параметр ISBN протестирован по:
- валидному сценарию  
- двум негативам (некорректный формат + длина)  

Покрытие: **среднее**, но достаточное.

## 4. Предполагаемые причины дефектов (Root Cause Hypothesis)

### A1 — Ошибка при спецсимволах
Вероятная причина:
- внутренних данных в одной из запись docs отсутствует поле, конвертируемое в Decimal  
- спецсимволы приводят к выборке неконсистентной записи в БД  
- Python-парсер не обрабатывает None

Это классический «input → unexpected DB shape → crash».

### A2 — Минимальная длина q
Это не баг, а:
- *business rule*, который не задокументирован в API  
или  
- *optimization rule*, введённый для снижения нагрузки на поиск

### A3 — XSS возвращается как строка
Причина:
- API возвращает «сырые» входные данные без валидации  
- но формат ответа — JSON, что делает атаку невозможной на уровне backend  
Проблема только при некорректной обработке на фронте.

### A4 — Rate limiting не протестирован
Причина:
- Postman Runner не запустил ни одного запроса  
- возможно, конфликт с авто-выбором Proxy  
- либо ошибка в тестовой коллекции

---

## 5. Риск-матрица (Risk Assessment)

| Аномалия                    |Severity                | Probability | Risk Level 
|                             |                        |             |
| 500 на спецсимволах         | High                   | Medium      | **High** 
| q<3 даёт 422                | Low                    | High        | Medium 
| XSS вернулся строкой        | Medium (frontend risk) | Low         | Low 

Главный риск — нестабильность при нестандартном вводе.

## 6. Рекомендации (Recommendations)

### Backend
- добавить валидацию входных данных для q  
- подавлять Python traceback перед отдачей ответа  
- документировать ограничение минимальной длины строки  
- добавить safe conversion вместо Decimal(None)

### API Documentation
- обновить спецификацию параметра q  
- указать максимальную длину строки  
- описать ограничения на спецсимволы  

### QA / Process
- добавить fuzzing-тест для q  
- протестировать комбинации параметра q с другими параметрами поиска  

## 7. Вывод
По результатам исследования API демонстрирует:

- высокую устойчивость для стандартного ввода  
- корректную работу SQL/XSS защиты  
- стабильность на длинных строках (до 5000 символов)

Однако:

- **спецсимволы приводят к 500**, что является серьёзным дефектом уровня backend  
- внутренняя ошибка Python указывает на отсутствие проверок данных перед сериализацией  
- документация API неполная

В целом API можно считать «стабильным, но с уязвимостью на неожиданный ввод».



